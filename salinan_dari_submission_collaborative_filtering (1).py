# -*- coding: utf-8 -*-
"""Salinan dari Submission-Collaborative-filtering.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12X9v3YrIHS6fzueFkUDi7lW0FtA1_zFq

# Submission - Diwa Prasetyo

## Data Preprocessing
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.metrics.pairwise import cosine_similarity

data_url = 'https://github.com/DiwaPrasetyo02/submission-collaborative-filtering/raw/main/Online%20Retail.xlsx'
retail_data = pd.read_excel(data_url)

print(retail_data.shape)
print(retail_data.info())

# Data Preprocessing
cleaned_data = retail_data[retail_data['Quantity'] > 0]
cleaned_data = cleaned_data.dropna(subset=['CustomerID'])
cleaned_data.drop_duplicates(inplace=True)
cleaned_data.reset_index(drop=True, inplace=True)
cleaned_data.head()

# Add a new column for Month-Year
cleaned_data['InvoiceDate'] = pd.to_datetime(cleaned_data['InvoiceDate'])
cleaned_data['MonthYear'] = cleaned_data['InvoiceDate'].dt.to_period('M')

# Add a new column for total price
cleaned_data['TotalPrice'] = cleaned_data['Quantity'] * cleaned_data['UnitPrice']

# Select relevant numerical features for correlation
numerical_features = cleaned_data[['Quantity', 'UnitPrice', 'TotalPrice']]

# Convert the 'InvoiceDate' column to datetime format
retail_data['InvoiceDate'] = pd.to_datetime(retail_data['InvoiceDate'])

# Get the minimum and maximum dates
start_date = retail_data['InvoiceDate'].min()
end_date = retail_data['InvoiceDate'].max()

start_date, end_date

"""### Jumlah Transaksi Tiap Negara
Grafik batang yang menunjukkan jumlah transaksi untuk setiap negara. Ini memberikan wawasan tentang negara mana yang memiliki jumlah transaksi terbanyak.
"""

plt.figure(figsize=(12, 6))
transactions_per_country = cleaned_data['Country'].value_counts()
sns.barplot(x=transactions_per_country.index, y=transactions_per_country.values, palette="viridis")
plt.title('Jumlah Transaksi per Negara')
plt.xlabel('Negara')
plt.ylabel('Jumlah Transaksi')
plt.xticks(rotation=90)
plt.show()

"""### Produk terlaris
Visualisasi ini memberikan wawasan tentang 10 produk mana yang paling populer di antara pelanggan. Ini bisa membantu dalam mengelola persediaan dan merencanakan strategi pemasaran untuk produk-produk yang paling laris.
"""

plt.figure(figsize=(12, 6))
top_products = cleaned_data['Description'].value_counts().head(10)
sns.barplot(x=top_products.values, y=top_products.index, palette="viridis")
plt.title('10 Produk Terlaris')
plt.xlabel('Jumlah Terjual')
plt.ylabel('Deskripsi Produk')
plt.show()

"""### Hubungan antara Jumlah Item dan Harga Satuan
hubungan antara jumlah item yang dibeli dan harga satuan. Sumbu x dan y menggunakan skala logaritmik untuk menangani rentang nilai yang luas. Ini dapat membantu mengidentifikasi pola atau anomali dalam data pembelian.
"""

plt.figure(figsize=(10, 6))
sns.scatterplot(data=cleaned_data, x='Quantity', y='UnitPrice', alpha=0.5)
plt.title('Hubungan antara Jumlah Item dan Harga Satuan')
plt.xlabel('Jumlah Item')
plt.ylabel('Harga Satuan')
plt.yscale('log')
plt.xscale('log')
plt.show()

"""### Jumlah Transaksi per Hari dalam Seminggu
Visualisasi ini membantu dalam memahami pola transaksi harian. Misalnya, apakah ada hari tertentu dalam seminggu di mana transaksi lebih banyak terjadi? Ini bisa membantu dalam pengambilan keputusan terkait promosi atau pengaturan stok.
"""

plt.figure(figsize=(12, 6))
cleaned_data['DayOfWeek'] = cleaned_data['InvoiceDate'].dt.day_name()
transactions_per_day = cleaned_data['DayOfWeek'].value_counts().reindex(
    ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
)
sns.barplot(x=transactions_per_day.index, y=transactions_per_day.values, palette="viridis")
plt.title('Jumlah Transaksi per Hari dalam Seminggu')
plt.xlabel('Hari dalam Seminggu')
plt.ylabel('Jumlah Transaksi')
plt.show()

"""### Heatmap Korelasi
Heatmap ini menunjukkan korelasi antara fitur-fitur numerik dalam dataset. Angka-angka dalam setiap sel menunjukkan nilai korelasi Pearson antara dua fitur. Warna pada heatmap menunjukkan kekuatan dan arah hubungan; merah tua menunjukkan korelasi positif yang kuat, biru tua menunjukkan korelasi negatif yang kuat, dan warna yang lebih terang menunjukkan korelasi yang lemah.
"""

# Compute the correlation matrix
correlation_matrix = numerical_features.corr()

# Plot the heatmap
plt.figure(figsize=(10, 8))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt='.2f')
plt.title('Heatmap Korelasi Fitur Numerik')
plt.show()

"""### Tren Pendapatan tiap Bulan
Membantu mengidentifikasi tren musiman dan fluktuasi pendapatan dari waktu ke waktu. Misalnya, apakah ada bulan-bulan tertentu dengan pendapatan yang lebih tinggi atau lebih rendah secara konsisten.
"""

# Calculate monthly revenue
monthly_revenue = cleaned_data.groupby('MonthYear')['TotalPrice'].sum()

# Plot the line chart
plt.figure(figsize=(12, 6))
monthly_revenue.plot(kind='line', marker='o', color='b')
plt.title('Tren Pendapatan per Bulan')
plt.xlabel('Bulan-Tahun')
plt.ylabel('Total Pendapatan')
plt.grid(True)
plt.show()

"""## Modeling

"""

# Customer-Item Matrix
customer_item_df = cleaned_data.pivot_table(
    index='CustomerID',
    columns='StockCode',
    values='Quantity',
    aggfunc='sum'
)

customer_item_df = customer_item_df.applymap(lambda x: 1 if x > 0 else 0)

# Modeling: User-User Similarity
user_similarity_matrix = pd.DataFrame(cosine_similarity(customer_item_df))
user_similarity_matrix.columns = customer_item_df.index
user_similarity_matrix['CustomerID'] = customer_item_df.index
user_similarity_matrix = user_similarity_matrix.set_index('CustomerID')

# Example of finding similar users
similar_users = user_similarity_matrix.loc[12350.0].sort_values(ascending=False)
print(similar_users.head())

# Items bought by a specific user
items_bought_by_user_A = set(customer_item_df.loc[12350.0].iloc[customer_item_df.loc[12350.0].to_numpy().nonzero()].index)
items_bought_by_user_B = set(customer_item_df.loc[17935.0].iloc[customer_item_df.loc[17935.0].to_numpy().nonzero()].index)

# Items to recommend
recommended_items_for_B = items_bought_by_user_A - items_bought_by_user_B
print(cleaned_data.loc[cleaned_data['StockCode'].isin(recommended_items_for_B), ['StockCode', 'Description']].drop_duplicates().set_index('StockCode'))

# Modeling: Item-Item Similarity
item_similarity_matrix = pd.DataFrame(cosine_similarity(customer_item_df.T))
item_similarity_matrix.columns = customer_item_df.T.index
item_similarity_matrix['StockCode'] = customer_item_df.T.index
item_similarity_matrix = item_similarity_matrix.set_index('StockCode')

# Finding top 10 similar items
top_similar_items = list(item_similarity_matrix.loc[23166].sort_values(ascending=False).iloc[:10].index)
print(cleaned_data.loc[cleaned_data['StockCode'].isin(top_similar_items), ['StockCode', 'Description']].drop_duplicates().set_index('StockCode').loc[top_similar_items])

# Evaluation
def precision_recall_at_k(user_similarity, item_similarity, user_id, k=10):
    similar_users = user_similarity.loc[user_id].sort_values(ascending=False).iloc[1:k+1].index
    recommended_items = set()
    for similar_user in similar_users:
        recommended_items.update(customer_item_df.loc[similar_user].iloc[customer_item_df.loc[similar_user].to_numpy().nonzero()].index)

    bought_items = set(customer_item_df.loc[user_id].iloc[customer_item_df.loc[user_id].to_numpy().nonzero()].index)
    relevant_items = recommended_items & bought_items

    precision = len(relevant_items) / len(recommended_items) if recommended_items else 0
    recall = len(relevant_items) / len(bought_items) if bought_items else 0

    return precision, recall

user_id_example = 12350.0
precision, recall = precision_recall_at_k(user_similarity_matrix, item_similarity_matrix, user_id_example)
print(f'Precision: {precision:.2f}, Recall: {recall:.2f}')